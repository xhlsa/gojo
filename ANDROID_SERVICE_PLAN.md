# Motion Tracker Android Foreground Service - Architecture Plan

## Overview
Replace Termux-based motion tracker with native Android foreground service + Rust core. Full native mobile app - no Python, no shell scripts on device.

## Architecture Layers

```
┌─────────────────────────────────────────────────────────────┐
│ Kotlin Android Layer (UI, Lifecycle, Android APIs)          │
│ ├─ MotionTrackerService (Foreground Service)               │
│ ├─ MotionTrackerActivity (UI, Settings)                    │
│ ├─ SensorManager (GPS, Accelerometer, Gyroscope)           │
│ ├─ WakeLock (Keep device awake)                            │
│ └─ Notification (Persistent notification + controls)       │
├─ JNI Bridge (Kotlin ↔ Rust FFI)                           │
├─ Rust Motion Tracker Core (Existing + Adapted)             │
│ ├─ ES-EKF, Complementary, Incident Detection              │
│ ├─ Sensor data callbacks (accel, gyro, GPS)               │
│ ├─ Session state machine (Started, Recording, Paused)     │
│ └─ File I/O (JSON/GPX to internal storage)                │
└─────────────────────────────────────────────────────────────┘
```

## File Structure

```
motion-tracker-android/                  (NEW Android project)
├── app/
│   ├── build.gradle.kts                 (Kotlin + NDK config)
│   ├── src/main/
│   │   ├── AndroidManifest.xml
│   │   ├── kotlin/com/example/motiontracker/
│   │   │   ├── MotionTrackerService.kt  (Foreground service)
│   │   │   ├── MotionTrackerActivity.kt (Main UI)
│   │   │   ├── SensorManager.kt         (Sensor integration)
│   │   │   ├── JniBinding.kt            (JNI FFI)
│   │   │   └── StorageManager.kt        (File I/O)
│   │   └── res/
│   │       ├── layout/
│   │       │   ├── activity_main.xml
│   │       │   └── notification_layout.xml
│   │       └── values/
│   └── src/main/jniLibs/              (Built .so files)
│
└── rust/                               (Rust JNI library)
    ├── Cargo.toml                      (cargo-ndk config)
    ├── src/
    │   ├── lib.rs                      (JNI exports)
    │   ├── android_jni.rs              (FFI layer)
    │   ├── sensor_receiver.rs          (Callback structs)
    │   ├── session.rs                  (State machine)
    │   └── storage.rs                  (File I/O)
    └── jni-headers/                    (Generated by cbindgen)
```

## Phase Implementation Plan

### Phase 1: Rust JNI Layer
**Goal:** Export start/stop functions via JNI that Kotlin can call

Files to create:
- `rust/Cargo.toml` (with jni, cargo-ndk)
- `rust/src/lib.rs` (JNI module exports)
- `rust/src/android_jni.rs` (FFI interface, Result-based errors)
- `rust/src/sensor_receiver.rs` (Callback structs for sensor data)
- `rust/src/session.rs` (State machine: Idle → Recording → Paused)

Key exports:
```rust
#[no_mangle]
pub extern "C" fn start_session(...) -> JResult
#[no_mangle]
pub extern "C" fn stop_session() -> JResult
#[no_mangle]
pub extern "C" fn push_accel_sample(x: f64, y: f64, z: f64, ts: f64) -> JResult
```

### Phase 2: Kotlin Foreground Service
**Goal:** Android service that manages lifecycle, sensors, persistence

Files to create:
- `app/src/main/kotlin/.../MotionTrackerService.kt`
- `app/src/main/kotlin/.../MotionTrackerActivity.kt`
- `app/src/main/kotlin/.../SensorManager.kt`
- `app/src/main/AndroidManifest.xml`

Key responsibilities:
- Start as foreground service with persistent notification
- Hold WakeLock (Kotlin PowerManager)
- Request sensor updates (LocationManager for GPS, SensorManager for IMU)
- Call Rust JNI functions with sensor data
- Handle lifecycle (onCreate → onStartCommand → onDestroy)

### Phase 3: JNI Bridge
**Goal:** Seamless Kotlin ↔ Rust communication

Implementation:
- `app/src/main/kotlin/.../JniBinding.kt` (Kotlin side)
- `rust/src/android_jni.rs` (Rust FFI)
- Build script: `build.gradle.kts` (cargo-ndk to compile .so)

Data flow:
```
Android Sensor (Kotlin)
  → SensorManager.onSensorChanged()
  → JniBinding.pushSample()
  → Rust FFI
  → motion_tracker_rs::filters
```

### Phase 4: Sensor Integration
**Goal:** Real sensor data (not mocked) flowing into Rust filters

Implementation:
- GPS via `android.location.LocationManager.NETWORK_PROVIDER` + `GPS_PROVIDER`
- Accelerometer/Gyro via `android.hardware.SensorManager.TYPE_ACCELEROMETER` etc.
- Callbacks → JNI → Rust session state

### Phase 5: File I/O
**Goal:** Session files (JSON/GPX) written to internal storage

Files to create:
- `rust/src/storage.rs` (Serialize session to JSON/GPX)

Paths:
- `context.getFilesDir()` → `/data/data/com.example.motiontracker/files/sessions/`
- File format: `comparison_TIMESTAMP_final.json` (matches current pattern)

## Error Handling Strategy

**Rust side:**
```rust
pub enum MotionTrackerError {
    AlreadyRunning,
    NotRunning,
    SensorFailed(String),
    StorageError(String),
    ...
}

pub type JResult<T> = Result<T, MotionTrackerError>;

// Convert to Java exceptions in JNI layer
fn throw_java_exception(env: JNIEnv, error: MotionTrackerError) { ... }
```

**Kotlin side:**
```kotlin
try {
    JniBinding.startSession()
} catch (e: MotionTrackerException) {
    // Handle gracefully, update notification
    Log.e("MotionTracker", "Start failed: ${e.message}")
}
```

## State Machine

```
        ┌─────────────────────┐
        │      Idle           │
        │ (service created)   │
        └────────┬────────────┘
                 │ startSession()
                 ↓
        ┌─────────────────────┐
        │    Recording        │
        │ (receiving samples) │
        └────────┬────────────┘
                 │ pauseSession()
                 ↓
        ┌─────────────────────┐
        │     Paused          │
        │ (not receiving)     │
        └────────┬────────────┘
                 │ stopSession()
                 ↓
        ┌─────────────────────┐
        │      Idle           │
        │ (session saved)     │
        └─────────────────────┘
```

## Constraints Adherence

- ✅ No unwrap/panic: All Result<T, Error> types
- ✅ Enums for state: SessionState enum + state transitions
- ✅ Minimize clones: Sensor data passed by reference, Arc only for thread-safe shared state
- ✅ Rust references over Arc: Local references in callbacks
- ✅ No Python on-device: Pure Kotlin + Rust, Android-native APIs

## Build Process

```bash
# Build Rust for Android
cd rust
cargo ndk -t arm64-v8a -t armeabi-v7a -o ../app/src/main/jniLibs build --release

# Build Android APK with Gradle
cd ..
./gradlew build
```

## Testing Strategy

1. **Unit tests (Rust):** Session state machine, error handling
2. **Integration tests (Kotlin):** JNI boundary testing
3. **E2E tests:** Manual testing with real device/sensors

## Success Criteria

- [ ] Service starts without crashing
- [ ] Notification persists (not dismissible)
- [ ] Sensor data flows through JNI
- [ ] Session file written to internal storage
- [ ] No panics in Rust code
- [ ] Graceful error handling on all error paths
- [ ] 30+ minute continuous recording without memory growth
